{"meta":{"title":"Daemon","subtitle":null,"description":"少年心性岁岁长，何必虚掷惊和慌","author":"Daemon","url":"https://shixiong.name","root":"/"},"pages":[{"title":"buddy","date":"2019-02-26T05:47:12.000Z","updated":"2019-08-19T07:17:21.504Z","comments":true,"path":"buddy/index.html","permalink":"https://shixiong.name/buddy/index.html","excerpt":"","text":"* Colin’s Nest* Vong* Punmy* 细语呢喃* 栖迟于一丘* B1ueW01f* 忘归* 进阶者* LIZIMEOW’S BLOG&gt; 🤙 排名不分先后"},{"title":"友情链接","date":"2019-08-19T07:18:52.299Z","updated":"2019-07-30T02:17:17.772Z","comments":false,"path":"links/index.html","permalink":"https://shixiong.name/links/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-21T13:09:38.000Z","updated":"2019-07-30T02:17:17.771Z","comments":true,"path":"about/index.html","permalink":"https://shixiong.name/about/index.html","excerpt":"","text":""},{"title":"唠叨","date":"2019-07-30T02:17:17.773Z","updated":"2019-07-30T02:17:17.773Z","comments":false,"path":"nag/index.html","permalink":"https://shixiong.name/nag/index.html","excerpt":"","text":"[2018-12-06 00:45] 所谓创新，其实并不复杂，这个时代，简单本身就是最好的创新。 [2018-12-06 00:40] 小说《去19号房间》里的妻子，发现自己出现了厌烦家庭生活的时刻。于是，便在房子里辟出了一个独处的房间，也跟家里人约定好这个空间只属于自己。但没多久，家人完全忘了这个约定，开始在这个房间里进进出出。后来这位妻子在宾馆里租了个房间作为个人私密空间，即使被误会外遇也不肯说出真相。其实每个人，都有属于自己的19号房间。再亲密的人也希望他能在门前止步，保持界限感。可往往很多人对界限感并没有清晰的认识，一不小心就越了界。 [2018-12-06 00:37] 社交的起因在于人们生活的单调和空虚。社交的需要驱使他们来到一起，但各自具有的许多令人厌憎的品行又驱使他们分开。 [2018-12-05 13:44] 影响力的另一个重要意义是，当他人认为你是（将成为）该领域的重要成员，他们才会愿意给与你机会或是资源。互联网行业人员流动性很大，往往今天对接的人明天离职就不知所踪了，这样的情况没有人原因付出太多精力和时间关注你的成长，更不可能给予你实际性的机会。让别人意识到，你会长久的呆在互联网行业，成为核心成员只是时间问题，大家就不会轻视你，并愿意在早期对你进行投资。 [2018-11-22 23:30] 可以！大功告成！:yum: [2018-11-22 23:29] 试试倒序发布~ [2018-11-22 22:05] 终于把bot弄好了，以后可以直接在slack里发东西，bot就会自动将内容发布到git-pages上，然后顺便把代码push到git上。自动化的魅力真是太迷人了.. [2018.11.22 15.50] 测试一下。 [2018.11.22 15:48] 搞了个记录碎碎念的地方。"}],"posts":[{"title":"一个奇怪的旋转问题","slug":"find-a-wierd-bug","date":"2019-07-30T02:24:32.000Z","updated":"2019-07-31T08:41:19.847Z","comments":true,"path":"2019/07/30/find-a-wierd-bug/","link":"","permalink":"https://shixiong.name/2019/07/30/find-a-wierd-bug/","excerpt":"","text":"现象最近发现一个很神奇的bug，加入某个会议之后然后退出，重复3次，界面就无法旋转了。 猜测猜测1⃣️无法旋转，在确认旋转锁定关闭的情况下，第一个想法是，看看support orientation 相关的函数返回值是否正确。 12345func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMaskopen override var shouldAutorotate: Bool open override var supportedInterfaceOrientations: UIInterfaceOrientationMask 于是打了三个全局断点，一个一个调试… 果不其然…都没什么问题… 但是这里有个现象，当出现bug（即无法旋转）的时候，这些函数都不会被调用了。 猜测2⃣️如果不是支持方向不对的话，回头看了一下现象：重复三次…于是继续猜测，会不会跟内存泄漏有关，之前有遇到过内存相关问题的现象也是重复操作n次出现。 于是调试了一下… 果不其然…还是没什么问题… 寻找思路前面的猜测都不对，一下子就懵逼了，毫无头绪。后来仔细想了想，要不试试从系统接口找找问题，既然要旋转，最后肯定会落地到系统层面的某个方法上。 于是打了个断点在 -[UIViewController shouldAutorotate] 当设备可以旋转的时候，调用栈如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1 * frame #0: 0x00000001d039de80 UIKitCore`-[UIViewController shouldAutorotate] frame #1: 0x00000001d039f8b8 UIKitCore`-[UIViewController _updateLastKnownInterfaceOrientationOnPresentionStack:] + 144 frame #2: 0x00000001d03a0e84 UIKitCore`-[UIViewController window:willAnimateRotationToInterfaceOrientation:duration:newSize:] + 92 frame #3: 0x00000001d03a8270 UIKitCore`__95-[UIViewController(AdaptiveSizing) _window:viewWillTransitionToSize:withTransitionCoordinator:]_block_invoke.3392 + 48 frame #4: 0x00000001d03af570 UIKitCore`-[_UIViewControllerTransitionCoordinator _applyBlocks:releaseBlocks:] + 264 frame #5: 0x00000001d03abb64 UIKitCore`-[_UIViewControllerTransitionContext __runAlongsideAnimations] + 176 frame #6: 0x00000001d0da7f40 UIKitCore`+[UIView(UIViewAnimationWithBlocks) _setupAnimationWithDuration:delay:view:options:factory:animations:start:animationStateGenerator:completion:] + 608 frame #7: 0x00000001d0da8480 UIKitCore`+[UIView(UIViewAnimationWithBlocks) animateWithDuration:delay:options:animations:completion:] + 108 frame #8: 0x000000010710a74c Glip`+[UIView(instrumentation) ADEumAnimateWithDuration:delay:options:animations:completion:] + 300 frame #9: 0x00000001d03c29e8 UIKitCore`__58-[_UIWindowRotationAnimationController animateTransition:]_block_invoke_2 + 308 frame #10: 0x00000001d0dac560 UIKitCore`+[UIView(Internal) _performBlockDelayingTriggeringResponderEvents:] + 220 frame #11: 0x00000001d03c2778 UIKitCore`__58-[_UIWindowRotationAnimationController animateTransition:]_block_invoke + 128 frame #12: 0x00000001d0da7f40 UIKitCore`+[UIView(UIViewAnimationWithBlocks) _setupAnimationWithDuration:delay:view:options:factory:animations:start:animationStateGenerator:completion:] + 608 frame #13: 0x00000001d0da8480 UIKitCore`+[UIView(UIViewAnimationWithBlocks) animateWithDuration:delay:options:animations:completion:] + 108 frame #14: 0x000000010710a74c Glip`+[UIView(instrumentation) ADEumAnimateWithDuration:delay:options:animations:completion:] + 300 frame #15: 0x00000001d03c2650 UIKitCore`-[_UIWindowRotationAnimationController animateTransition:] + 456 frame #16: 0x00000001d0968398 UIKitCore`-[UIWindow _rotateToBounds:withAnimator:transitionContext:] + 580 frame #17: 0x00000001d096aafc UIKitCore`-[UIWindow _rotateWindowToOrientation:updateStatusBar:duration:skipCallbacks:] + 1184 frame #18: 0x00000001d096b1b0 UIKitCore`-[UIWindow _setRotatableClient:toOrientation:updateStatusBar:duration:force:isRotating:] + 516 frame #19: 0x00000001d096a5b0 UIKitCore`-[UIWindow _setRotatableViewOrientation:updateStatusBar:duration:force:] + 128 frame #20: 0x00000001d096925c UIKitCore`__57-[UIWindow _updateToInterfaceOrientation:duration:force:]_block_invoke + 124 frame #21: 0x00000001d0969160 UIKitCore`-[UIWindow _updateToInterfaceOrientation:duration:force:] + 560 frame #22: 0x00000001a43595bc CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20 frame #23: 0x00000001a4359588 CoreFoundation`___CFXRegistrationPost_block_invoke + 64 frame #24: 0x00000001a4358a7c CoreFoundation`_CFXRegistrationPost + 392 frame #25: 0x00000001a4358728 CoreFoundation`___CFXNotificationPost_block_invoke + 96 frame #26: 0x00000001a42d2524 CoreFoundation`-[_CFXNotificationRegistrar find:object:observer:enumerator:] + 1496 frame #27: 0x00000001a43581d8 CoreFoundation`_CFXNotificationPost + 696 frame #28: 0x00000001a4d40814 Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:] + 68 frame #29: 0x00000001d05c2030 UIKitCore`-[UIDevice setOrientation:animated:] + 328 frame #30: 0x00000001d01f071c UIKitCore`__124-[_UICanvasDeviceOrientationSettingsDiffAction _updateDeviceOrientationWithSettingObserverContext:canvas:transitionContext:]_block_invoke + 88 frame #31: 0x00000001d01f2304 UIKitCore`_performChangesWithTransitionContext + 836 frame #32: 0x00000001d01f0688 UIKitCore`-[_UICanvasDeviceOrientationSettingsDiffAction _updateDeviceOrientationWithSettingObserverContext:canvas:transitionContext:] + 236 frame #33: 0x00000001d01f058c UIKitCore`__133-[_UICanvasDeviceOrientationSettingsDiffAction performActionsForCanvas:withUpdatedScene:settingsDiff:fromSettings:transitionContext:]_block_invoke + 104 frame #34: 0x00000001d01f1fb0 UIKitCore`_performActionsWithDelayForTransitionContext + 112 frame #35: 0x00000001d01f04e0 UIKitCore`-[_UICanvasDeviceOrientationSettingsDiffAction performActionsForCanvas:withUpdatedScene:settingsDiff:fromSettings:transitionContext:] + 172 frame #36: 0x00000001d01f5d84 UIKitCore`-[_UICanvas scene:didUpdateWithDiff:transitionContext:completion:] + 360 frame #37: 0x00000001d05253b8 UIKitCore`-[UIApplicationSceneClientAgent scene:handleEvent:withCompletion:] + 464 frame #38: 0x00000001a6d63920 FrontBoardServices`__80-[FBSSceneImpl updater:didUpdateSettings:withDiff:transitionContext:completion:]_block_invoke_3 + 224 frame #39: 0x00000001356e4c74 libdispatch.dylib`_dispatch_client_callout + 16 frame #40: 0x00000001356e8840 libdispatch.dylib`_dispatch_block_invoke_direct + 232 frame #41: 0x00000001a6d9d0bc FrontBoardServices`__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 40 frame #42: 0x00000001a6d9cd58 FrontBoardServices`-[FBSSerialQueue _performNext] + 408 frame #43: 0x00000001a6d9d310 FrontBoardServices`-[FBSSerialQueue _performNextFromRunLoopSource] + 52 frame #44: 0x00000001a437a2bc CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24 frame #45: 0x00000001a437a23c CoreFoundation`__CFRunLoopDoSource0 + 88 frame #46: 0x00000001a4379b24 CoreFoundation`__CFRunLoopDoSources0 + 176 frame #47: 0x00000001a4374a60 CoreFoundation`__CFRunLoopRun + 1004 frame #48: 0x00000001a4374354 CoreFoundation`CFRunLoopRunSpecific + 436 frame #49: 0x00000001a657479c GraphicsServices`GSEventRunModal + 104 frame #50: 0x00000001d092bb68 UIKitCore`UIApplicationMain + 212 frame #51: 0x000000010525d370 Glip`main at AppDelegate.swift:67:7 frame #52: 0x00000001a3e3a8e0 libdyld.dylib`start + 4 最后通过断点定位，发现问题出在 12345678frame #22: 0x00000001a43595bc CoreFoundation`__CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__ + 20frame #23: 0x00000001a4359588 CoreFoundation`___CFXRegistrationPost_block_invoke + 64frame #24: 0x00000001a4358a7c CoreFoundation`_CFXRegistrationPost + 392frame #25: 0x00000001a4358728 CoreFoundation`___CFXNotificationPost_block_invoke + 96frame #26: 0x00000001a42d2524 CoreFoundation`-[_CFXNotificationRegistrar find:object:observer:enumerator:] + 1496frame #27: 0x00000001a43581d8 CoreFoundation`_CFXNotificationPost + 696frame #28: 0x00000001a4d40814 Foundation`-[NSNotificationCenter postNotificationName:object:userInfo:] + 68frame #29: 0x00000001d05c2030 UIKitCore`-[UIDevice setOrientation:animated:] + 328 不论APP是否支持旋转，[UIDevice setOrientation:animated:] 都会调用，且参数值也是对的。关键在于下一步，当APP支持旋转的时候，会发出一个UIDeviceOrientationDidChangeNotification 通知，不支持旋转的时候就不会。 于是问题就转化成了：什么情况下，系统有可能会不发出 UIDeviceOrientationDidChangeNotification 通知呢？ 遇事不决，看文档。 在 UIDevice.h 中找到这三个玩意儿 123@property(nonatomic,readonly,getter=isGeneratingDeviceOrientationNotifications) BOOL generatesDeviceOrientationNotifications __TVOS_PROHIBITED;- (void)beginGeneratingDeviceOrientationNotifications __TVOS_PROHIBITED; // nestable- (void)endGeneratingDeviceOrientationNotifications __TVOS_PROHIBITED; 看着应该就是罪魁祸首了。 定位问题调试发现，在APP支持旋转时 isGeneratingDeviceOrientationNotifications = true；不支持时 isGeneratingDeviceOrientationNotifications=false。 查看 generatesDeviceOrientationNotifications 文档： If the value of this property is YES, the shared UIDevice object posts a UIDeviceOrientationDidChangeNotification notification when the device changes orientation. If the value is NO, it generates no orientation notifications. Device orientation notifications can only be generated between calls to the beginGeneratingDeviceOrientationNotifications and endGeneratingDeviceOrientationNotifications methods. 查看 beginGeneratingDeviceOrientationNotifications 文档： You must call this method before attempting to get orientation data from the receiver. This method enables the device’s accelerometer hardware and begins the delivery of acceleration events to the receiver. The receiver subsequently uses these events to post UIDeviceOrientationDidChangeNotification notifications when the device orientation changes and to update the orientation property.You may nest calls to this method safely, but you should always match each call with a corresponding call to the endGeneratingDeviceOrientationNotifications method. 所以 isGeneratingDeviceOrientationNotifications 的值是受另外两个方法影响的。 看来已经找到原因了 继续调试发现，项目代码内部并没有调用到 beginGeneratingDeviceOrientationNotifications 和 endGeneratingDeviceOrientationNotifications。 结论当 -[UIWindow setRootViewController:]的时候，系统会调用 beginGeneratingDeviceOrientationNotifications，当 -[UIWindow dealloc] 时，会调用 endGeneratingDeviceOrientationNotifications，这么看系统的这个逻辑是没什么问题的。问题出在于 WebRTC 中，在 start video session 的时候有调用 beginGeneratingDeviceOrientationNotifications，stop video session 的时候有调用 endGeneratingDeviceOrientationNotifications。但是CoreLib里的代码有点问题，start video session 的时候并没有调用 beginGeneratingDeviceOrientationNotifications ，导致这两个没有成对出现，从而出错。 以前没有特别关注过这三者： 123@property(nonatomic,readonly,getter=isGeneratingDeviceOrientationNotifications) BOOL generatesDeviceOrientationNotifications __TVOS_PROHIBITED;- (void)beginGeneratingDeviceOrientationNotifications __TVOS_PROHIBITED; // nestable- (void)endGeneratingDeviceOrientationNotifications __TVOS_PROHIBITED; 以后遇到旋转问题，又多了一条思路了..","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shixiong.name/tags/iOS/"},{"name":"Orientation","slug":"Orientation","permalink":"https://shixiong.name/tags/Orientation/"}]},{"title":"【译】写给自己的软件工程笔记","slug":"note-to-myself-on-software-engineering","date":"2019-03-29T08:53:45.000Z","updated":"2019-07-30T02:17:17.770Z","comments":true,"path":"2019/03/29/note-to-myself-on-software-engineering/","link":"","permalink":"https://shixiong.name/2019/03/29/note-to-myself-on-software-engineering/","excerpt":"","text":"这是 Keras 的开发者 François Chollet 整理的笔记，里面有很多思考值得学习。原文链接 在开发过程中 代码不仅仅意味着要被执行的。代码也是团队之间的沟通方式，是向他人描述问题解决方案的一种方式。（写出）具有较高可读性的代码不是一件值得骄傲的事情，它是编写代码最基础的部分了。这其中包括清楚地分解代码，选择不言自明的变量名，并插入合适的注释来描述隐含的任何内容。 当你提交每个PR的时候，要思考的不是这个PR能给你的下次升职带来什么，而应该是这个PR可以为你的用户和社区做些什么。要不惜一切代价地避免“狠显眼的贡献”。如果不是很明显的能帮助产品的目的，就请不要添加任何功能。 代码也是有品位的。品味是由对简单的渴望而产生符合约束-满足规范的过程，要时刻保持着对简单的执念。 敢于拒绝 - 只是因为有人要求提供功能并不意味着你应该这么做。每项功能的成本都超出了最初的实施范围：因为有维护成本、文档成本和用户的认知成本。如果你总是问：我们真的应该这样做吗？通常答案都会是否定的。 当你对用户提出的新的功能需求说“是”时，请记住，用户要的东西通常都不是最佳的选择。用户值专注于他们自己的特定的需求，你必须以项目的整体性和自有的原则来应对这一点。通常正确的答案会是扩展现有的功能。 在持续集成和以全面覆盖单元测试为目标这两件事上多投入。这样可以确保你能处在一个自信的编码环境中；如果不是这样，那么首要任务就应该是关注建立正确的基础设施。 没有提前计划好一些没有关系。不断地尝试然后看看结果如何。提早纠错，确保你创建了一个没有不可能的环境。 好的软件会让事情变得简单。仅仅因为一开始问题看起来很困难并不意味着解决方案必须复杂或难以使用。很多时候，在一个会有更容易的方案但可能不是那么明显的情况下，工程师往往会条件反射式地选择引入复杂度很高的解决方案（让我们使用ML！让我们构建一个应用程序！让我们添加区块链！）。在你写下任何代码前，确保你的解决方案不能再简单了。任何事情遵循第一性原理。 避免很隐晦的规则。当你发现自己开发了一种较为隐晦的规则时，应保持规则明确并与他人共享或自动化。每当你发现自己想出一个反复的，准算法的工作流程时，应该设法将其形式化为一个文档化的流程，以便其他团队成员从该体验中受益。此外，你应该设法在自动化这种任何可被自动化的工作流程部份（例如，正确性检查）。 在设计过程中应考虑你所做选择的全局影响，而不仅仅是自己想要关注的部分 - 例如收入或增长。除了你当前正在监控的指标之外，你的软件对全球用户的总体影响是什么？是否存在超出价值主张的不良副作用？在保留软件实用性的同时，你可以做些什么来解决它们？ 道德设计，将你的价值观融入在你的创作中。 API设计 你的API是有用户的，所以它应该也要有用户体验。在你做出的每一个决定中，都要牢记你的用户。对用户充满同理心，无论他们是初学者还是经验老道的老司机。 始终寻求在使用API​​的过程中尽量减少对用户的认知负担。自动化可自动化的内容，最大限度地减少用户所需的操作和选择，不要暴露不重要的选项，设计简单一致的工作流程，以反映简单一致的心理模型。 简单的事情应该是简单的，复杂的事情应该是可能的（Simple things should be simple, complex things should be possible. —-Alan Kay）。不要为了小众用例增加常见用例的认知负荷，即使影响很小。 如果工作流的认知负荷足够低，那么用户应该可以在完成一次或两次之后就可以记住它（无需查阅教程或文档）。 寻求拥有与领域专家和从业者的心理模型相匹配的API。拥有领域经验但对你的API没有经验的人应该能够看最少的文档就能直观地明白你的API，很多时候只需要通过查看几个代码示例并查看哪些对象可用以及它们的签名是什么。 在没有任何关于底层实现的上下文情况下，参数的含义应该是可理解的。必须由用户指定的参数应该与用户对问题的心理模型有关，而不是跟代码的实现细节有关。API代表的是它解决了什么问题，而不是它背后是如何运行的。 最强大的心理模型是模块化和分层的：高度简单，但是当你需要了解细节时，又很精细。同样，一个好的API是模块化和分层的：易于使用，但又具有表现力。对象少，但签名复杂，与对象多但签名简单之间存在着一个平衡。一个好的API应该有合理数量的对象，且具有相当简单的签名。 你的API不可避免地反映了你选择的实现，特别是你选择的数据结构。要实现直观的API，你必须一开始就选择自然适合的数据结构 - 与该领域专家的心智模型相匹配。 故意设计端到端工作流程，而不是一组原子功能。大多数开发人员会询问：”应该提供哪些功能来处理API设计？让我们为他们配置选项吧。“相反地，应该问：该工具的用例是什么？对于每个用例，用户操作的最佳顺序是什么？什么是可以支持这个工作流程最简单的API？ API中的原子选项应该能够满足高级工作流程中出现的明确需求 - 不应该“因为有人可能需要它”就添加它们。 错误消息以及通常在与API交互过程中向用户提供的任何反馈都是API的一部分。交互性和反馈是用户体验不可或缺的一部分。要为你的API设计错误消息。 因为代码是一种交流，所以命名很重要 - 无论是项目还是变量的命名。名称反映了你对问题的看法。避免使用过于通用的名称（x，变量，参数），避免 OverlyLongAndSpecificNamingPatterns，避免可能产生不必要的术语（主，从），并确保在命名选择中保持一致。命名一致性意味着内部命名一致性（不要一些地方用”dim“代表坐标轴，在另一些地方用”axis“）以及与问题域的既定约定的一致性。在命名之前，应尽量使用该领域专家（或其他API）已在使用的命名。 文档是API用户体验的核心，它不是附属品。在高质量的文档上多花时间，你会得到比在更多功能上多花时间更高的回报。 展示，而不是解释：你的文档不应该讨论软件的工作原理，它应该说明如何使用它。展示端到端工作流的代码示例、显示API的每个常见用例和关键功能的代码示例。 生产力归结为快速决策和执行力。 软件生涯 职业发展并不是你管理人数的多少，而是你所产生的影响，这个世界有你没你会有多大的差别? 软件开发是一项团队合作；它与人际关系和技术能力有关。做个好伙伴，当你不断前行时，不要忘了与人保持联系。 技术永远不会是中立的。如果你的工作对世界有任何影响，那么这种影响就有道德方向。我们在软件产品中看似无害的技术选择都会被充满使用动机，谁将受益，谁将受到影响。技术选择也是道德选择。因此，始终谨慎而明确地表达你想要支持的价值观。道德设计，将您的价值观融入您的创作中。永远不要想，我只是在建立这种能力，这本身是中立的。你构建它的方式无法决定它被使用的方式。 自我引导，你的工作和环境的力量，是生活满意度的关键。确保你给予周围的人充分的自我引导，并确保你的职业选择能够为你自己带来更多的力量。 去创造这个世界需要的东西，而不仅仅是你希望拥有的东西。技术人员常常会边过着稀薄的生活，边专注于满足自身特定需求的产品。寻找机会拓宽你的生活体验，让自己能更好地发现这个世界需要什么。 在做出会有长期影响的任何选择时，请将你的价值观置于短期的自身利益和过度的情绪之上 - 例如贪婪或恐惧。认清你的价值观，并让它们引导你。 当我们发现自己陷入冲突时，先暂停下来并承认我们的共同价值观和共同目标是个不错的主意，提醒彼此，我们是在同一条船上的。 生产力归结为高速决策和执行力。这需要a）良好的直觉，这来自以往的经验，它可以帮你在只给出部分信息的情况下就做出普遍正确的决定; b）敏锐地意识到何时应该更谨慎的行动并等待更多信息，因为错误决策会比延期付出更高的代价。最快的速度/最好的质量之间的决策往往会在不同环境而有不同的权衡。 更快地做出决策意味着你在职业生涯中要做出更多决策，这将使你对正确的选项有更强的直觉。经验是提高生产力的关键，更高的生产力将为你提供更多的经验：良性循环。 在你意识到缺乏直觉的情况下，请遵守抽象原则。在整个职业生涯中建立尝试过且正确的原则列表。原则是形式化的直觉，相比于原始直觉（需要对类似情况的有直接且丰富的经验），它能适用于更广泛的场景。","categories":[],"tags":[{"name":"心得","slug":"心得","permalink":"https://shixiong.name/tags/心得/"},{"name":"软件工程","slug":"软件工程","permalink":"https://shixiong.name/tags/软件工程/"}]},{"title":"ARTS挑战-第二周","slug":"arts-second-week","date":"2019-03-29T08:16:23.000Z","updated":"2019-07-30T02:17:17.743Z","comments":true,"path":"2019/03/29/arts-second-week/","link":"","permalink":"https://shixiong.name/2019/03/29/arts-second-week/","excerpt":"","text":"什么是ARTS？ 1.Algorithm：每周至少做一个 leetcode 的算法题2.Review：阅读并点评至少一篇英文技术文章3.Tip：学习至少一个技术技巧4.Share：分享一篇有观点和思考的技术文章 Algorithm 一开始以为这道题目挺难的，后来其实慢慢的研究下去发现还好，就是2数相加，需要考虑进位的问题。代码提交后看了一下Solution，发现思路大致也差不多。一开始还怀疑自己，没想到能抓到老鼠的都是好猫。 Q: You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. A: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Definition for singly-linked list. * public class ListNode &#123; * public var val: Int * public var next: ListNode? * public init(_ val: Int) &#123; * self.val = val * self.next = nil * &#125; * &#125; */class Solution &#123; /// 两个数字相加，并返回十位和个位 func addNum(_ num1: Int, _ num2: Int) -&gt; (high: Int, low: Int) &#123; var resultH = 0 var resultL = 0 let sum = num1 + num2 if sum &gt;= 10 &#123; resultH = 1 resultL = sum - 10 &#125; else &#123; resultL = sum &#125; return (resultH, resultL) &#125; func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123; if let l1 = l1, let l2 = l2 &#123; var node1: ListNode? = l1 var node2: ListNode? = l2 var cursor: ListNode? var waitToAdd: Int = 0 var result: ListNode? = ListNode(-1) while true &#123; // 当两个node节点均为空了停止循环 if node1 == nil, node2 == nil &#123; break &#125; // 构建空节点 if node1 == nil &#123; node1 = ListNode(0) &#125; if node2 == nil &#123; node2 = ListNode(0) &#125; let r = addNum(node1!.val, node2!.val) let t = addNum(r.low, waitToAdd) if t.high == 1 &#123; waitToAdd = t.high &#125; else &#123; waitToAdd = r.high &#125; if result?.val == -1 &#123; result?.val = t.low cursor = result &#125; else &#123; let node = ListNode(t.low) cursor?.next = node cursor = node &#125; node1 = node1!.next node2 = node2!.next &#125; if waitToAdd != 0 &#123; cursor?.next = ListNode(1) &#125; return result &#125; if l1 == nil &#123; return l2 &#125; if l2 == nil &#123; return l1 &#125; return nil &#125;&#125; Review这一篇 Pro Pattern-Matching in Swift 把 Swift 中的 Pattern[ˈpatərn]-Matching 讲得比较详细了。 Pattern-Matching 是 Swift 中一个能把代码写得整洁又安全的方式，必须掌握。 TipSwift 中部分高阶函数对比（以操作数组为例）：map vs flatMap vs compactMap vs filter vs reduce map将数组中的每个元素进行一次操作 flatMap同map，但是不会返回nil，且会对数组中的 optional 进行解包 compactMap如果 flatMap 的回调中可能返回 optional，则需要使用 compactMap ‘flatMap’ is deprecated: Please use compactMap(_:) for the case where closure returns an optional value filter顾名思义，可以按照 closure 中的标准，把数组中的一些元素过滤掉 reducereduce 就是可以把数组拍平，比如一个 [String]，用 reduce 可以让它返回成 String ShareNotes to Myself on Software Engineering，这是 Keras 的开发者 François Chollet 整理的笔记，里面有很多思考值得学习。由于写得太好了，我把它翻译了一下。","categories":[],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"https://shixiong.name/tags/ARTS/"}]},{"title":"ARTS挑战-第一周","slug":"arts-first-week","date":"2019-03-25T08:25:19.000Z","updated":"2019-07-30T02:17:17.743Z","comments":true,"path":"2019/03/25/arts-first-week/","link":"","permalink":"https://shixiong.name/2019/03/25/arts-first-week/","excerpt":"","text":"什么是ARTS？ 1.Algorithm：每周至少做一个 leetcode 的算法题2.Review：阅读并点评至少一篇英文技术文章3.Tip：学习至少一个技术技巧4.Share：分享一篇有观点和思考的技术文章 AlgorithmQ: Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. A: 123456789101112131415class Solution &#123; func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123; for (i, firstItem) in nums.enumerated() &#123; for j in i+1..&lt;nums.count &#123; let secondItem = nums[j] let sum = firstItem + secondItem if sum == target &#123; return [i, j] &#125; &#125; &#125; return [] &#125;&#125; Review这周分享的一篇技术文章是Designing a workflow with functions that are capable of failing，主要介绍了更好的错误处理工作流，包括Swift里标准库新加入的Result，以及适配重试网络请求等逻辑。（这两天找个时间翻译一下） Tip这周在写Swift的时候，由于我在一个变量的didSet中加入了一些处理的方式，在某些情况下，需要触发变量的didSet方法，于是就会有这样的代码：self.model = self.model，这个时候Xcode会报警：assign a property to itself。所以在Swift里，是不能把自己赋给自己的。 怎么解决呢？ 12let temp = self.modelself.model = temp 这样子就简单解决了。可是这样子其他想 assign a property to itself 的地方就得也这么写一遍，有点繁琐。于是就在思考有没有更好的办法呢？ 可以通过自定义operator 12345prefix operator &lt;&lt;prefix func &lt;&lt; &lt;T: Any&gt;(t: T) -&gt; T &#123; let temp = t return temp&#125; 这样在想要把自己赋给自己的地方这么写就行了 1self.model &lt;&lt;= self.model Share这周重温了一下objc的 行为驱动开发 有时候改变自己的思维方式真不是一件容易的事，但是当真的能接受新的思考方式并转变的话，一定会有更大的突破的。","categories":[],"tags":[{"name":"ARTS","slug":"ARTS","permalink":"https://shixiong.name/tags/ARTS/"}]},{"title":"探究使用Method Swizzling的正确姿势","slug":"the-right-way-to-swizzling","date":"2019-03-01T03:07:43.000Z","updated":"2019-07-30T02:17:17.770Z","comments":true,"path":"2019/03/01/the-right-way-to-swizzling/","link":"","permalink":"https://shixiong.name/2019/03/01/the-right-way-to-swizzling/","excerpt":"","text":"背景初次接触到OC runtime机制的时候，应该都会被其黑魔法所折服。特别是在使用了Method Swizzling来hook某一个方法，改变一个已经存在的 selector 的实现的时候，实现AOP统计打点、APM检测、… 都成为了可能。 危害然而，越是强大的力量，背后往往会隐藏着更大的危险。 在Stackoverflow上，有一篇文章：《What are the Dangers of Method Swizzling in Objective C?》，里面已经把OC中方法交换的危险描述得非常清楚了，这里做个简要的概述。 1. Method swizzling并非是原子操作其实95%的场景下，使用 Method Swizzling 都是安全的。因为我们一般希望在整个APP的生命周期里方法的替换是有效的，所以我们会在 +(void)load 方法里执行一系列的操作， 这个情况下是不会遇到并发问题的。但是如果不小心将代码写到了 +(void)initialize 中，就会有可能出现非常诡异的情况。 其实也应该尽可能少的在 +(void)initialize 中做操作，否则会影响启动速度。 2. 会更改到并非是我们自身代码的实现其实这个也是想一下就能明白的问题。如果你在没搞清楚状况的情况下去进行方法替换，可能会影响到其他人的代码。特别是，如果重写了一个类的方法时，却没有调用父类的方法，可能就会出现问题。因此为了避免可能出现的未知情况，我们最好还是要在替换方法实现里调用一下原始实现。 3. 可能会存在命名冲突在 Method Swizzling 的时候，我们一般会在新的方法前加上一个前缀。 如: 1234- (void)my_setFrame:(NSRect)frame &#123; // do custom work [self my_setFrame:frame]; &#125; 但是这样有一个问题，就是万一有某一个地方，也定义了 - (void)my_setFrame:(NSRect)frame 这个名字的方法，就可能出现问题。 因此最好的解决方式还是在于使用函数指针来解决这个问题（不过这样代码看起来就不那么OC了）。 12345678910111213141516171819@implementation NSView (MyViewAdditions) static void MySetFrame(id self, SEL _cmd, NSRect frame); static void (*SetFrameIMP)(id self, SEL _cmd, NSRect frame); static void MySetFrame(id self, SEL _cmd, NSRect frame) &#123; // do custom work SetFrameIMP(self, _cmd, frame); &#125; + (void)load &#123; [self swizzle:@selector(setFrame:) with:(IMP)MySetFrame store:(IMP *)&amp;SetFrameIMP]; &#125; @end 作者也给出了一个比较完美的swizzle方法的定义： 1234567891011121314151617181920212223typedef IMP *IMPPointer; BOOL class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMPPointer store) &#123; IMP imp = NULL; Method method = class_getInstanceMethod(class, original); if (method) &#123; const char *type = method_getTypeEncoding(method); imp = class_replaceMethod(class, original, replacement, type); if (!imp) &#123; imp = method_getImplementation(method); &#125; &#125; if (imp &amp;&amp; store) &#123; *store = imp; &#125; return (imp != NULL); &#125; @implementation NSObject (FRRuntimeAdditions) + (BOOL)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store &#123; return class_swizzleMethodAndStore(self, original, replacement, store); &#125; @end 4. 会改变方法的参数作者认为这是一个最大的问题。当你替换了一个方法之后，其实你也替换了传入原始方法实现的参数。 1[self my_setFrame:frame]; 这一行做的事情是： 1objc_msgSend(self, @selector(my_setFrame:), frame); runtime会去寻找 my_setFrame: 的实现，一旦找到了，就会把 my_setFrame 和 frame 传入，但其实这个时候找到的方法应该是原始的 setFrame:，于是当它被调用的时候，_cmd 这个参数并不是预期 setFrame:，而是 my_setFrame，这样就接收了一个意料之外的参数。 最好的方式还是使用如上的定义。 5. 方法交换带来的顺序问题当对多个类进行方法交换的时候，要注意顺序，特别是有父子类关系的时候。比如： 123[NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)];[NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)];[NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)]; 上述的实现，其实最终当你调用 NSButton 的 setFrame 的时候，会调用你替换的 my_buttonSetFrame 方法和 NSView 的原始的 setFrame 的方法。 相反的，如果顺序是这样的话： 123[NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)];[NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)];[NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)]; 就会分别调用 NSButton 、 NSControl 和 NSView 的交换后的方法，这个顺序应该来说才是正确的。 所以其实这边还是建议在 +(void)load 方法里做方法交换，它可以保证父类的load方法在子类的方法调用前先调用，不会出错。 6. 会带来很多理解和调试上的不便这个就不用多说了，特别是没有文档的时候。有时候要是遇到同事写在某一个角落里的runtime操作但是没人知道的话，搞出了一些无法预见的问题，调试起来就很是蛋疼。 正确姿势所以正确的 Method Swizzling 的姿势是什么呢？ ① 如上面的作者一直强调的，在load里进行方法替换 ②其实上面作者给出的 swizzle完美定义 已经是比较正确的姿势了。但是这里也记录下另一个问题。 网上一部分的文章，都会讲到，通过 Category 实现 Method Swizzling 的例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // When swizzling a class method, use the following: // Class class = object_getClass((id)self); // ... // Method originalMethod = class_getClassMethod(class, originalSelector); // Method swizzledMethod = class_getClassMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@\"viewWillAppear: %@\", self);&#125;@end 然而这里有一点不够严谨，也是之前有提到的危险性所在，origin_imp 如果使用了 _cmd 参数，hook之后的_cmd 是不符合预期的。 假设我们现在要hook - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; 那么如果如上那么实现的话，在 [self xxx_touchesBegan:touches withEvent:event]; 就会崩溃。原因是这个函数里有 forwardTouchMethod, 反汇编后实现类似： 1234567891011121314151617181920212223242526static void forwardTouchMethod(id self, SEL _cmd, NSSet *touches, UIEvent *event) &#123; // The responder chain is used to figure out where to send the next touch UIResponder *nextResponder = [self nextResponder]; if (nextResponder &amp;&amp; nextResponder != self) &#123; // Not all touches are forwarded - so we filter here. NSMutableSet *filteredTouches = [NSMutableSet set]; [touches enumerateObjectsUsingBlock:^(UITouch *touch, BOOL *stop) &#123; // Checks every touch for forwarding requirements. if ([touch _wantsForwardingFromResponder:self toNextResponder:nextResponder withEvent:event]) &#123; [filteredTouches addObject:touch]; &#125;else &#123; // This is interesting legacy behavior. Before iOS 5, all touches are forwarded (and this is logged) if (!_UIApplicationLinkedOnOrAfter(12)) &#123; [filteredTouches addObject:touch]; // Log old behavior static BOOL didLog = 0; if (!didLog) &#123; NSLog(@\"Pre-iOS 5.0 touch delivery method forwarding relied upon. Forwarding -%@ to %@.\", NSStringFromSelector(_cmd), nextResponder); &#125; &#125; &#125; &#125;]; // here we basically call [nextResponder touchesBegan:filteredTouches event:event]; [nextResponder performSelector:_cmd withObject:filteredTouches withObject:event]; &#125;&#125; 如果我们exchange了 IMP, [nextResponder performSelector:_cmd withObject:filteredTouches withObject:event]; 是没有相应的实现的，_cmd 就变成了 我们替换的 SEL。 显然，nextResponder没有实现相应的方法，就会crash。 那么这里可以这么写： 123456789101112131415161718192021222324252627282930313233343536373839404142static IMP __original_TouchesBegan_Method_Imp;@implementation UIView (Debug)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(touchesBegan:withEvent:); SEL swizzledSelector = @selector(dae_touchesBegan:withEvent:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); __original_TouchesBegan_Method_Imp = method_getImplementation(originalMethod); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)dae_touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // custom void (*functionPointer)(id, SEL, NSSet&lt;UITouch *&gt; *, UIEvent *) = (void(*)(id, SEL, NSSet&lt;UITouch *&gt; *, UIEvent*))__original_TouchesBegan_Method_Imp; functionPointer(self, _cmd, touches, event);&#125; 这样就能找到正确的IMP了。 参考链接Method Swizzling 的正确途径The Right Way to Swizzle in Objective-CWhat are the Dangers of Method Swizzling in Objective C?","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shixiong.name/tags/iOS/"},{"name":"Runtime","slug":"Runtime","permalink":"https://shixiong.name/tags/Runtime/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://shixiong.name/tags/Objective-C/"},{"name":"Method Swizzling","slug":"Method-Swizzling","permalink":"https://shixiong.name/tags/Method-Swizzling/"}]},{"title":"由于Python版本太低遇到的环境问题备忘","slug":"python-backend-memo","date":"2019-02-25T07:57:53.000Z","updated":"2019-07-30T02:17:17.770Z","comments":true,"path":"2019/02/25/python-backend-memo/","link":"","permalink":"https://shixiong.name/2019/02/25/python-backend-memo/","excerpt":"","text":"这两天在倒腾用Python写个接口，遇到一些问题，特此做下记录备忘，方便后面查阅。 Error - A true SSLContext object is not available InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSLappropriately and may cause certain SSL connections to fail. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning. 这是因为我服务器上的Python版本太低了，如果Python版本低于2.7.9之前的话，就会有这个错误提示，因为2.7.9之前的Python提供的SSL环境不是很安全。 所以理所当然我们就要升级Python的版本了。 Install Python3.7cat /etc/redhat-release 看了一眼系统是 CentOS 6 于是先使用yum安装环境依赖。 1234567891011121314151617181920212223242526272829303132333435# wget 用于下载源码包# gcc 和 make 用于编译yum install wget gcc make#make报错，Python 有个很重要的内建模块 zipimport 用于从 Zip 压缩包中导入模块#zipimport.ZipImportError: can't decompress data; zlib not availableyum install zlib-devel#make install报错，#ModuleNotFoundError: No module named ‘_ctypes’yum install libffi-devel# 解决 import ssl 报错 No module named '_ssl'yum install openssl-devel# 解决 import bz2 报错yum install bzip2-devel# 解决 import curses 报错yum install ncurses-devel# 解决 import sqlite3 报错yum install sqlite-devel# 解决 _dbm _gdbm 缺失提醒yum install gdbm-devel# 解决 _lzma 缺失提醒yum install xz-devel# 解决 _tkinter 缺失提醒yum install tk-devel# 解决 readline 缺失提醒及方向键行为非预期的问题yum install readline-devel 然后下载源码包 wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tar.xz 解压缩 12xz -d Python-3.7.1.tar.xztar -xvf Python-3.7.1.tar 编译&amp;安装 12345cd Python-3.7.1#--prefix 是预期安装目录，--enable-optimizations 是优化选项（LTO，PGO 等）./configure --prefix=/usr/local/python3.7 --enable-optimizations# 安装make &amp;&amp; make install 添加软链接 12ln -s /usr/local/python3.7/bin/python3.7 /usr/bin/python3ln -s /usr/local/python3.7/bin/pip3.7 /usr/bin/pip3 这样子应该一切就搞定啦。然而，事情好像没有那么简单。 当我尝试使用 pip3 install flask 的时候，报错。 Error - OpenSSL version pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available. 前边说过，我的服务器系统是CentOS 6，默认的OpenSSL版本是1.0.1，而Python3.7需要OpenSSL1.0.2或者1.1.x才行，于是我们需要对OpenSSL进行升级并且重新编辑Pyton3.7。 升级OpenSSL下载最新版的OpenSSL wget https://www.openssl.org/source/openssl-1.1.1-pre8.tar.gz 编译&amp;安装 123cd openssl-1.1.1-pre8./config --prefix=/usr/local/openssl no-zlib #不需要zlibmake &amp; make install 备份原配置 12mv /usr/bin/openssl /usr/bin/openssl.bakmv /usr/include/openssl/ /usr/include/openssl.bak 添加软链接 123ln -s /usr/local/openssl/include/openssl /usr/include/opensslln -s /usr/local/openssl/lib/libssl.so.1.1 /usr/local/lib64/libssl.soln -s /usr/local/openssl/bin/openssl /usr/bin/openssl 修改系统配置 1234#写入openssl库文件的搜索路径echo \"/usr/local/openssl/lib\" &gt;&gt; /etc/ld.so.conf#使修改后的/etc/ld.so.conf生效 ldconfig -v 重新编译Python3.7 12345cd Python-3.7.1#--prefix 是预期安装目录，--enable-optimizations 是优化选项（LTO，PGO 等）./configure --prefix=/usr/local/python3.7 --enable-optimizations --with-openssl=/usr/local/openssl# 安装make &amp;&amp; make install 至此，所有问题都解决了。感想：Linux里的相关环境配置，真是一门大学问啊 参考Flask安装: A true SSLContext object is not availableCentOS 7 下安装 Python3.7.1python3.7安装后ssl问题","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://shixiong.name/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://shixiong.name/tags/Flask/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://shixiong.name/tags/OpenSSL/"},{"name":"Linux","slug":"Linux","permalink":"https://shixiong.name/tags/Linux/"}]},{"title":"Sublime Text 使用备忘","slug":"sublimetext-remind","date":"2018-12-24T13:56:15.000Z","updated":"2019-07-30T02:17:17.770Z","comments":true,"path":"2018/12/24/sublimetext-remind/","link":"","permalink":"https://shixiong.name/2018/12/24/sublimetext-remind/","excerpt":"","text":"快捷键备忘 【control+tab】：在tab之间切换 【command+j】：合并两行 【command+l】：选择当前行 【command+enter】：下一行开辟新行 【shift+command+enter】：上一行开辟新行 【option+鼠标左键】：块选择并进入多点编辑模式 【option+左右键】：移动一个单词（+shift 同时进行选择） 【command+左右键】：行首行位切换 【shift+command+p】：在命令中直接输入文档类型（如css等可直接切换） 【shift+command+p】：reindent lines 代码风格缩进 配置文件那么如何绑定快捷键呢，首先 shift+command+p 打开命令面板，输入keybindings，点击 Key Bindings - User，在配置文件中加入 [{&quot;key&quot;: [&quot;shift+tab&quot;], &quot;command&quot;: &quot;reindent&quot;, &quot;agrs&quot;: {&quot;single_line&quot;: false }},]。 那么如何知道具体命令是什么呢？可以通过 control+` 打开工作台，在工作台中输入 sublime.log_commands(True)，然后再通过shift+command+p打开命令面板，输入 reindent lines, 就可以在下边的工作台中看到具体命令名及参数了。 那么所有的配置都保存到哪了呢？ 可以点击左上角的 Sublime Text - Preferences - browse Packages...这个时候应该会打开到这个目录下 ~/Library/Application Support/Sublime Text 3/Packages，具体的根据环境不同路径会不同。 在该目录下，用户的所有配置项会存在User文件夹中，并且这些配置文件都是纯文本的，所以可以支持版本控制。 除了这个之外，还有一些自定义项也可以通过 shift+command+p 打开命令面板，输入 settings 打开 Preferences: Settings - User 便可找到配置自定义配置项的配置文件了。 使用Packages Control安装扩展包安装 Packages Control 的方法可以参考这个 Installation - Package Control 官网上也有很多库可供选择。安装完Packages Control之后，包都会存放在 ~/Library/Application Support/Sublime Text 3/Packages 里边的 Installed Packages 里。并且会在 Packages/User 里新加一个 Packge Control.sublime-settings 配置项。 推荐的一些扩展包 AdvancedNewFileEmmetGitSassSublimeERBSyncedSideBar 快速查找正常情况下，可以通过 command+p 直接输入模糊搜索： eg: 模糊搜索名+冒号+行号，如：demo:10，光标会直接停在第10行eg: 搜索名@函数名会跳转到函数名，如：demo@new 可以通过 command+f 在本文件中进行查找： enter：搜索下一处；shift+enter：搜索上一处；esc：停在当前单词command+d n次，可以同时编辑，并进入多点编辑 要在文件夹下查找的话，需要在文件夹上右键，点击 find in finder，会把相应的内容记在一个文本里，按F4可以跳转到第一个查找项，或者也可以直接在文本里用鼠标双击打开。 跳走了可以用 control+- 直接跳回去。如果跳多了，可以 control+shift+- 可以再进行回到上一级的操作。 Emmet牛逼！（todo） 代码片段（todo） 自动补齐（todo） /user下的 damemon.sublime-completions sublimeCodeIntel build system（todo）","categories":[],"tags":[{"name":"sublime text","slug":"sublime-text","permalink":"https://shixiong.name/tags/sublime-text/"}]},{"title":"与Cocoapods抗战的一天","slug":"fight-with-cocoapods","date":"2018-05-22T14:43:54.000Z","updated":"2019-07-30T02:17:17.769Z","comments":true,"path":"2018/05/22/fight-with-cocoapods/","link":"","permalink":"https://shixiong.name/2018/05/22/fight-with-cocoapods/","excerpt":"","text":"在升级Mac系统到macOS High Sierra（10.13.4）的时候，出现升级失败导致开不了机，所有的数据全没了。🌶🐔🍎💊之前的系统环境都要全部重新配置，在配置cocoapods的时候遇到了一些问题，特此记录。 安装cocoapods依赖的环境这步网上有很多教程，就不再赘述。然而安装完后，在执行 pod install 或 pod update 时，就会出现如下错误： 12345678910111213141516ArgumentError - Malformed version number string/Library/Ruby/Site/2.3.0/rubygems/version.rb:209:in `initialize&apos;/Library/Ruby/Site/2.3.0/rubygems/version.rb:200:in `new&apos;/Library/Ruby/Site/2.3.0/rubygems/version.rb:200:in `new&apos;/Library/Ruby/Gems/2.3.0/gems/cocoapods-1.5.2/lib/cocoapods/generator/xcconfig/aggregate_xcconfig.rb:123:in `embedded_content_settings&apos;/Library/Ruby/Gems/2.3.0/gems/cocoapods-1.5.2/lib/cocoapods/generator/xcconfig/aggregate_xcconfig.rb:68:in `generate&apos;/Library/Ruby/Gems/2.3.0/gems/cocoapods-1.5.2/lib/cocoapods/generator/xcconfig/aggregate_xcconfig.rb:39:in `save_as&apos;.../Library/Ruby/Gems/2.3.0/gems/cocoapods-1.5.2/lib/cocoapods/installer.rb:183:in `generate_pods_project&apos;/Library/Ruby/Gems/2.3.0/gems/cocoapods-1.5.2/lib/cocoapods/installer.rb:119:in `install!&apos;/Library/Ruby/Gems/2.3.0/gems/cocoapods-1.5.2/lib/cocoapods/command/install.rb:41:in `run&apos;/Library/Ruby/Gems/2.3.0/gems/claide-1.0.2/lib/claide/command.rb:334:in `run&apos;/Library/Ruby/Gems/2.3.0/gems/cocoapods-1.5.2/lib/cocoapods/command.rb:52:in `run&apos;/Library/Ruby/Gems/2.3.0/gems/cocoapods-1.5.2/bin/pod:55:in `&lt;top (required)&gt;&apos;/usr/bin/pod:23:in `load&apos;/usr/bin/pod:23:in `&lt;main&gt;&apos; （一脸懵逼…） Google搜了一堆也没找到解决办法，后来在Cocoapods的issues里找到一个解决方案: jcharr1: I came across this issue today, too, when trying to run “pod install.” What version of Rubygems are you running? For me, I had updated with gem update --system which brought me up to v2.7.7. Downgrading to 2.7.6 with gem update --system 2.7.6 fixed this for me. 这位 jcharr1 说gem版本太高了导致的，他降级到2.7.6就可以了。于是我也尝试着降级了一下，果然解决了！不过其中缘由不得而知，有时间再研究一下。 Pod install现在可以正常 pod install 和 pod update 了吗？并不。当我按下回车键之后，又出现了一个小问题： 1234Analyzing dependenciesPre-downloading: `XXXX` from `http://xxx.com/xxx/xxx.git`, tag `xxx_6.9.5`Username for &apos;http://xxx.com&apos;: aaaPassword for &apos;http://aaa@xxx.com&apos;: 其实这个输入账号密码就能解决问题了，但是我比较好奇的是我已经有添加了 SSH Key，为什么还会要我输入账号密码呢？原来，当我们的pod组件的地址使用的是 http/https 地址的时候，就会使用账号密码验证，当使用ssh地址的时候，就会用 SSH Key 验证。所以当我们不想输入账号密码的时候，可以在 ~/.gitconfig 中加入如下代码： 123456[url &quot;git@github.com:&quot;] insteadOf = https://github.com/[url &quot;git@github.com:&quot;] pushInsteadOf = &quot;git://github.com/&quot;[url &quot;git@github.com:&quot;] pushInsteadOf = &quot;https://github.com/&quot; 相关地址可以根据具体情况具体修改，修改完之后就会强制使用 ssh 验证了。 然后 pod install，可以了吗？不！它又出错了。 12[!] Error installing MTCameraAR[!] Failed to download &apos;MTCameraAR&apos; （一脸懵逼again…） 后来尝试卸载重装cocoapods，都不行。正当无可奈何之际，突然想起来，pod有 --verbose 这个参数啊，说不定会有帮助。于是 pod install --verbose 关键的错误就出现了， git-lfs: command not found由于这个库的文件都很大，没有使用git-lfs的话会超时，无法成功拉取。所以只要安装git-lfs就好了。 bingo！问题都解决了。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shixiong.name/tags/iOS/"}]},{"title":"用 Swift 协议扩展和泛型来实现复用[译]","slug":"yong-swift-xieyi-tuozhan-fuyong","date":"2016-11-11T12:56:15.000Z","updated":"2019-07-30T02:17:17.771Z","comments":true,"path":"2016/11/11/yong-swift-xieyi-tuozhan-fuyong/","link":"","permalink":"https://shixiong.name/2016/11/11/yong-swift-xieyi-tuozhan-fuyong/","excerpt":"","text":"作为一个iOS开发者，最常用的任务就是通过自定义cell的子类，来实现UITableView或者UICollectionView的自定义。并且 UITableView 和 UICollectionView 在注册自定义cell子类这一块都有非常类似的API: 12public func registerClass(cellClass: AnyClass?, forCellWithReuseIdentifier identifier: String)public func registerNib(nib: UINib?, forCellWithReuseIdentifier identifier: String) 对于注册cell的自定义最常用的解决办法就是，声明一个reuseIdentifier的常量，像下面这样: 1234567891011121314151617181920212223private let reuseIdentifier = \"BookCell\"class BookListViewController: UIViewController, UICollectionViewDataSource &#123; @IBOutlet private weak var collectionView: UICollectionView! override func viewDidLoad() &#123; super.viewDidLoad() let nib = UINib(nibName: \"BookCell\", bundle: nil) self.collectionView.registerNib(nib, forCellWithReuseIdentifier: reuseIdentifier) &#125; func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123; let cell = collectionView.dequeueReusableCellWithReuseIdentifier(reuseIdentifier, forIndexPath: indexPath) if let bookCell = cell as? BookCell &#123; // TODO: configure cell &#125; return cell &#125;&#125; 接下来让我们尝试着使用泛型来让它简单化和安全化。 首先，如果在我们的代码当中能不需要到处声明reuse identifier常量，那就再好不过了。而事实上，我们可以直接使用自定义cell的类名来当做 默认的reuseIdentifier。我们可以通过创建一个Reuseable Views的协议并且创建默认的声明方法给 UIView 的子类们。 123456789101112protocol ReusableView: class &#123; static var defaultReuseIdentifier: String &#123; get &#125;&#125;extension ReusableView where Self: UIView &#123; static var defaultReuseIdentifier: String &#123; return NSStringFromClass(self) &#125;&#125;extension UICollectionViewCell: ReusableView &#123;&#125; 通过让 UICollectionViewCell 遵循 ReusableView 协议，我们可以得到每个cell子类的一个唯一的重用标识。 12let identifier = BookCell.defaultReuseIdentifier// identifier = \"MyModule.BookCell\" 接下来，我们通过同样的方法，将注册Nib步骤中的一些脏代码给去除掉。 我们创建一个 Nib Loadable Views 的协议并通过协议拓展添加一个默认方法实现。 123456789101112protocol NibLoadableView: class &#123; static var nibName: String &#123; get &#125;&#125;extension NibLoadableView where Self: UIView &#123; static var nibName: String &#123; return NSStringFromClass(self).componentsSeparatedByString(\".\").last! &#125;&#125;extension BookCell: NibLoadableView &#123;&#125; 通过让我们的 BookCell 类遵循 NibLoadableView 协议，现在我们就有了一个更安全和方便的方法去获得到Nib的名称。 12let nibName = BookCell.nibName// nibName = \"BookCell\" 有这两个协议，我们可以通过使用 Swift的泛型 并且通过拓展 UICollectionView 来简化cell的注册和使用。 123456789101112131415161718192021extension UICollectionView &#123; func register&lt;T: UICollectionViewCell where T: ReusableView&gt;(_: T.Type) &#123; registerClass(T.self, forCellWithReuseIdentifier: T.defaultReuseIdentifier) &#125; func register&lt;T: UICollectionViewCell where T: ReusableView, T: NibLoadableView&gt;(_: T.Type) &#123; let bundle = NSBundle(forClass: T.self) let nib = UINib(nibName: T.nibName, bundle: bundle) registerNib(nib, forCellWithReuseIdentifier: T.defaultReuseIdentifier) &#125; func dequeueReusableCell&lt;T: UICollectionViewCell where T: ReusableView&gt;(forIndexPath indexPath: NSIndexPath) -&gt; T &#123; guard let cell = dequeueReusableCellWithReuseIdentifier(T.defaultReuseIdentifier, forIndexPath: indexPath) as? T else &#123; fatalError(\"Could not dequeue cell with identifier: \\(T.defaultReuseIdentifier)\") &#125; return cell &#125; &#125; 注意这里，我们创建了两个版本的注册方法，一个是用来注册 ReusableView 子类用的，一个是用来注册 ReusableView 和 NibLoadableView的子类。这很好的将view controller的特定的注册方法分离出来。 另一个比较棒的细节就是 dequeueReusableCell 方法不再需要给他任何重用标识字符串而且可以直接使用cell的子类作为返回值。 现在cell的注册和使用代码看起来棒极了 :) 。 1234567891011121314151617181920class BookListViewController: UIViewController, UICollectionViewDataSource &#123; @IBOutlet private weak var collectionView: UICollectionView! override func viewDidLoad() &#123; super.viewDidLoad() self.collectionView.register(BookCell.self) &#125; func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123; let cell: BookCell = collectionView.dequeueReusableCell(forIndexPath: indexPath) // TODO: configure cell return cell &#125; ...&#125; 总结如果你是从 Objective-C 转到 Swift 的话，研究Swift强大的新特性比如 协议拓展、 泛型， 从而找到更优雅的实现方式和替代方法是非常值得的。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shixiong.name/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://shixiong.name/tags/Swift/"}]},{"title":"贝塞尔曲线指北","slug":"bezier-zhibei","date":"2016-11-03T09:37:01.000Z","updated":"2019-07-30T02:17:17.743Z","comments":true,"path":"2016/11/03/bezier-zhibei/","link":"","permalink":"https://shixiong.name/2016/11/03/bezier-zhibei/","excerpt":"","text":"最近在做项目的时候，需要用到一个动画，非常简单的动画，简单到就是直接对一个View做平移… 然而虽然动画简单，但是却很不自然，尝试了UIView Animation提供的各类参数，都无法达到想要的动画效果。这时候，我的脑子里突然想起一个词… “贝塞尔曲线”…. 这个词经常看到，但却从没有去了解过，这次就趁着有求于它的雅兴，好好做个入门了解好了。 什么是贝塞尔曲线？ 显而易见的是，贝塞尔曲线，应该就是是一个叫贝塞尔的人发明的曲线吧，然而历史剧本却不是这么写的。贝塞尔曲线所依据的最原始的数学公式，是早在1912年就广为人知的伯恩斯坦多项式。OK，now，What is boensitan duoxiangshi？！简单来说，伯恩斯坦多项式可以用来证明，在[ a, b ] 区间上所有的连续函数都可以用多项式来逼近，并且收敛性很强，也就是一致收敛。再简单点，就是一个连续函数，你可以将它写成若干个伯恩斯坦多项式相加的形式，并且，随着 n→∞，这个多项式将一致收敛到原函数，这个就是伯恩斯坦斯的逼近性质。 不知道在说什么鬼？没关系，接着说.. 到了1959年，当时就职于雪铁龙的法国数学家 Paul de Casteljau 开始对伯恩斯坦多项式进行了图形化的尝试，并且提供了一种数值稳定的德卡斯特里奥（de Casteljau） 算法。根据这个算法，就可以只通过很少的控制点，去生成复杂的平滑曲线，也就是贝塞尔曲线。 而贝塞尔曲线的得名，得归功于1962年就职于雷诺的法国工程师皮埃尔·贝塞尔（Pierre Bézier），他使用这种方法来辅助汽车的车体工业设计，并且广泛宣传，因此大家才都称他为贝塞尔曲线 。 贝塞尔曲线是怎么画出来的？首先，我们在平面内选3个不同线的点并且依次用线段连接。如下所示..接着，我们在AB和BC线段上找出点D和点E，使得AD/AB = BE/BC。再接着，连接DE，并在DE上找出一点F，使得DF/DE = AD/AB = BE/BC。然后，根据我们高中所学的极限的知识，让选取的点D在第一条线段上从起点A，移动到终点B，找出所有点F，并将它们连起来。最后你会发现，你得到了一条非常光滑的曲线，这条就是传说中的，贝塞尔曲线。看这里… 这是二阶贝塞尔曲线。 下面是三阶四阶和五阶。 最后是… 一阶…. 所以贝塞尔曲线的厉害之处就在这里，从1-n阶的连续函数，他都可以计算得到一条光滑曲线。 贝塞尔曲线有什么用？为什么经常会听到这个名称？由于贝塞尔曲线控制简便，而且它具有很强的描述能力，因此它在工业设计上已经被广泛使用了。不仅如此，在计算机图形学领域（特别是矢量图形学），贝塞尔曲线也有着举足轻重的地位。而作为程序猿，我们经常会用贝塞尔曲线来绘图（由贝塞尔曲线画出来的图很光滑~），来做动画（很自然的动画）等等。也就是由于它可以发挥的作用领域太广了，因此我们时不时都会听到这个名字。 如何使用贝塞尔曲线？首先，要明确的一点是，对于贝塞尔曲线来说，最重要的点是，数据点和控制点。数据点： 指一条路径的起始点和终止点。控制点：控制点决定了一条路径的弯曲轨迹，根据控制点的个数，贝塞尔曲线被分为一阶贝塞尔曲线（0个控制点）、二阶贝塞尔曲线（1个控制点）、三阶贝塞尔曲线（2个控制点）等等。而系统给我们提供了一个叫做UIBezierPath类，用它可以画简单的圆形，椭圆，矩形，圆角矩形，也可以通过添加点去生成任意的图形，还可以简单的创建一条二阶贝塞尔曲线和三阶贝塞尔曲线。 用法1：简单地画图形这里的简单用法就不细讲，虽然类名叫UIBezierPath，但画圆形啥的跟贝塞尔也没啥关系，直接贴代码。 画圆形 12345UIBezierPath *bPath = [UIBezierPath bezierPathWithArcCenter:CGPointMake(300, 300) radius:50 startAngle: DEGREES_TO_RADIANS(135) endAngle:M_PI*2 clockwise:YES]; [bPath setLineWidth:5]; //绘制 [bPath stroke]; 画椭圆 123UIBezierPath *ovalPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(200, 150, 100, 200)]; [ovalPath setLineWidth:5]; [ovalPath stroke]; 画矩形 12345UIBezierPath *myBezierPath = [UIBezierPath bezierPathWithRect:CGRectMake(20, 20, 100, 50)]; [[UIColor blackColor]setStroke]; [myBezierPath setLineWidth:5]; [myBezierPath stroke]; 画圆角矩形 1234567//UIRectCorner可以设置 哪几个角是圆角，其他不变 UIBezierPath *tBPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(220, 20, 100, 100) byRoundingCorners:UIRectCornerTopLeft | UIRectCornerBottomLeft cornerRadii:CGSizeMake(20, 20)]; [[UIColor greenColor]setStroke]; [tBPath setLineWidth:5]; [tBPath stroke]; 通过任意点画任意图形 1234567891011121314151617181920212223UIBezierPath* aPath = [UIBezierPath bezierPath];aPath.lineWidth = 15.0; aPath.lineCapStyle = kCGLineCapButt; //线条终点 //round 圆形 //butt 平的 默认值 把线连接到精准的终点 //Square 平的，会把线延伸到终点再加上线宽的一半 aPath.lineJoinStyle = kCGLineJoinBevel; //拐点处理 //bevel 斜角斜面，角的外侧是平的不圆滑 //miter 斜接 角的外侧是尖的 //round 圆角 //这是起点 [aPath moveToPoint:CGPointMake(100.0, 200.0)]; //添加点 [aPath addLineToPoint:CGPointMake(200.0, 240.0)]; [aPath addLineToPoint:CGPointMake(160, 340)]; [aPath addLineToPoint:CGPointMake(40.0, 340)]; [aPath addLineToPoint:CGPointMake(10.0, 240.0)]; [aPath closePath]; //第五条线通过调用closePath方法得到的 [aPath stroke]; //Draws line 根据坐标点连线 画二阶贝塞尔 12345678910UIBezierPath* twoPath = [UIBezierPath bezierPath]; twoPath.lineWidth = 5.0;//宽度 twoPath.lineCapStyle = kCGLineCapRound; //线条拐角 twoPath.lineJoinStyle = kCGLineJoinRound; //终点处理 //起始点 [twoPath moveToPoint:CGPointMake(20, 100)]; //添加两个控制点 [twoPath addQuadCurveToPoint:CGPointMake(220, 100) controlPoint:CGPointMake(170, 0)]; //划线 [twoPath stroke]; 画三阶贝塞尔1234567891011UIBezierPath* bPath = [UIBezierPath bezierPath]; bPath.lineWidth = 5.0; bPath.lineCapStyle = kCGLineCapRound; //线条拐角 bPath.lineJoinStyle = kCGLineCapRound; //终点处理 //起始点 [bPath moveToPoint:CGPointMake(20, 250)]; //添加两个控制点 [bPath addCurveToPoint:CGPointMake(350, 250) controlPoint1:CGPointMake(310, 200) controlPoint2:CGPointMake(210, 400)]; [bPath stroke]; 用法2：用贝塞尔曲线圆滑绘图这个用法可以说是处女座的福音。假设这么一个场景：产品提了个需求，来吧，咱们来做一个你画我猜的APP。你画我猜？肯定是要先有画了。简单！新建个UIView的子类，然后在它的初始化方法中创建Path和手势。 123456// Create a path to connect linespath = [UIBezierPath bezierPath];// Capture touchesUIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];pan.maximumNumberOfTouches = pan.minimumNumberOfTouches = 1;[self addGestureRecognizer:pan]; 再将捕获到的pan事件location数据依次加入到path中，并且用直线连接两点。 123456789- (void)pan:(UIPanGestureRecognizer *)pan &#123; CGPoint currentPoint = [pan locationInView:self]; if (pan.state == UIGestureRecognizerStateBegan) &#123; [path moveToPoint:currentPoint]; &#125; else if (pan.state == UIGestureRecognizerStateChanged) &#123; [path addLineToPoint:currentPoint]; &#125; [self setNeedsDisplay];&#125; 最后画出轨迹。 1234- (void)drawRect:(CGRect)rect &#123; [[UIColor blackColor] setStroke]; [path stroke]; &#125; 最后将这个view添加到控制器上，很开心的Command + R，让程序跑起来。 开始画~然后你就会发现，画出来的曲线是这样的。。 WHAT THE FXXK!!怎么可以有这么多锯齿。。所以这个时候，贝塞尔曲线就很有用了。它的定义是可以找到两点之间的光滑曲线，因为我们之前手势移动的时候，两点之间都是使用直线连接，如果我们可以使用贝塞尔曲线连接，那应该就不会出现这个问题了。试一下。首先写一个计算中点的方法，我们到时会使用这个中点作为控制点。 123456static CGPoint midpoint(CGPoint p0, CGPoint p1) &#123; return (CGPoint) &#123; (p0.x + p1.x) / 2.0, (p0.y + p1.y) / 2.0 &#125;; &#125; 最后将手势处理中的连接方式替换成使用贝塞尔曲线。 123456789101112- (void)pan:(UIPanGestureRecognizer *)pan &#123; CGPoint currentPoint = [pan locationInView:self]; CGPoint midPoint = midpoint(previousPoint, currentPoint); if (pan.state == UIGestureRecognizerStateBegan) &#123; [path moveToPoint:currentPoint]; &#125; else if (pan.state == UIGestureRecognizerStateChanged) &#123; [path addQuadCurveToPoint:midPoint controlPoint:previousPoint]; &#125; previousPoint = currentPoint; [self setNeedsDisplay]; &#125; 再Run一次… 看，光滑多了~所以很多时候，当我们遇到画出的图形太不自然的时候，就可以试着用贝塞尔曲线解决这些问题，用到越高阶的曲线，画出的图形越光滑。 用法3：用贝塞尔曲线做变形网上看到的大多数比较酷炫的动画，都是通过修改曲线的控制点，对曲线进行变形而做的。比如，我们要实现如下一个动画。 这个动画最难地方就是手势拖拽的时候，直线的变形，可以首先的想到的是使用贝塞尔。通过创建path，添加控制点画出曲线，然后通过更改控制点的位置来达到让曲线进行变形的目的。 如上图所示，这里添加了7个点，从左到右依次为l3、l2、l1、c、 r1、 r2、 r3。屏幕最左和最右两边的l3和r3没有在图中显示出来，然后我们就可以以l3和l2为控制点，从l3到l1建立一条二阶贝塞尔曲线，再以c和r1为控制点建一条从l3到r1的曲线，最后以r1和r2为控制点建一条从r1到r3的曲线。 主要代码如下： 12345678910111213141516171819- (CGPathRef)currentPath &#123; CGFloat width = self.view.bounds.size.width; UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(0, 0)]; [path addLineToPoint:CGPointMake(0, self.l3ControlPointView.center.y)]; [path addCurveToPoint:self.l1ControlPointView.center controlPoint1:self.l3ControlPointView.center controlPoint2:self.l2ControlPointView.center]; [path addCurveToPoint:self.r1ControlPointView.center controlPoint1:self.cControlPointView.center controlPoint2:self.r1ControlPointView.center]; [path addCurveToPoint:self.r3ControlPointView.center controlPoint1:self.r1ControlPointView.center controlPoint2:self.r2ControlPointView.center]; [path addLineToPoint:CGPointMake(width, 0)]; [path closePath]; return path.CGPath; &#125; 建立好路径之后，就可以通过手势操作来修改控制点的坐标达到我们的目的了。在这里也就是修改l3到r3的中心点坐标。主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637- (void)panDidMove:(UIPanGestureRecognizer *)gesture &#123; if (gesture.state == UIGestureRecognizerStateEnded || gesture.state == UIGestureRecognizerStateFailed || gesture.state == UIGestureRecognizerStateCancelled) &#123; &#125; else &#123; CGFloat additionalHeight = MAX([gesture translationInView:self.view].y, 0); CGFloat waveHeight = MIN(additionalHeight*0.6, kMaxWaveHeight); CGFloat baseHeight = kMiniHeight + additionalHeight - waveHeight; CGFloat locationX = [gesture locationInView:gesture.view].x; [self layoutControlPoints:baseHeight waveHeight:waveHeight locationX:locationX]; [self updateShapeLayer]; &#125; &#125; - (void)layoutControlPoints:(CGFloat)baseHeight waveHeight:(CGFloat)waveHeight locationX:(CGFloat)locationX &#123; CGFloat width = self.view.bounds.size.width; CGFloat minLeftX = MIN(locationX-width/2*0.28, 0); CGFloat maxRightX = MAX(width+(locationX-width)/2 *0.28, width); CGFloat leftPartWidth = locationX - minLeftX; CGFloat rightPartWidth = maxRightX - locationX; self.l3ControlPointView.center = CGPointMake(minLeftX, baseHeight); self.l2ControlPointView.center = CGPointMake(minLeftX+leftPartWidth*0.44, baseHeight); self.l1ControlPointView.center = CGPointMake(minLeftX+leftPartWidth*0.71, baseHeight+waveHeight*0.64); self.cControlPointView.center = CGPointMake(locationX, baseHeight+waveHeight*1.36); self.r1ControlPointView.center = CGPointMake(maxRightX-rightPartWidth*0.71, baseHeight+waveHeight*0.64); self.r2ControlPointView.center = CGPointMake(maxRightX-(rightPartWidth*0.44), baseHeight); self.r3ControlPointView.center = CGPointMake(maxRightX, baseHeight); &#125; - (void)updateShapeLayer &#123; self.shapeLayer.path = [self currentPath]; &#125; 通过这个思路，我们可以做出很多有意思而且有生命力的动画，这里一般还会经常和 CADisplayLink 一起用，先留个坑。 用法4：用贝塞尔曲线做缓冲动画做动画最主要的一点，就是要让动画达到很自然的效果。这就要涉及到一些现实中的物理知识，比如重力弹力和速度等等，所以有时候，我们需要对动画的速度进行控制，有时候需要先快再慢，有时候需要先慢再快然后再慢，有时候又需要快慢超慢非常慢…这个时候就不得不提到 CAMediaTimingFunction 。CAMediaTimingFunction 的主要用法可以理解为我们在一个二维坐标系上建议一条或曲线或直线的函数，这个函数的斜率就是动画的速度，斜率的改变量也就是导数则为加速度。理论上来说，这个坐标系上的任何曲线都可以用来当做加速动画。然而CAMediaTimingFunction 只给我们提供了一个三次贝塞尔曲线的函数，它可以生成三次贝塞尔曲线所能生成的所有缓冲函数。这里刚好可以介绍 一个 两个好用的网站： http://www.roblaplaca.com/examples/bezierBuilder这个网站可以做到可视化的修改两个控制点，来达到生成一条三阶贝塞尔曲线，并且还会给出两个控制点的具体坐标，以及右边还可以看到这条曲线产生的动画会做怎样的速度改变。也就是说，只要我们能拿到两个控制点的坐标，就可以用来控制动画了。http://easings.net这个网站提供了丰富的曲线类型可供选择，图表旁还有一个小动画预览，非常直观。比如下面这段代码，就可以让我们把相册从4：3 切换到1：1 的时候，展示一个先快后慢的过渡效果，这个效果跟系统相机的还是蛮接近的。 12345678910CABasicAnimation *animation = [CABasicAnimation animation];animation.keyPath = @\"borderWidth\";animation.repeatCount = 1;animation.duration = 0.4;animation.removedOnCompletion = NO;animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:0 :1 :1 :1];animation.fillMode = kCAFillModeForwards;animation.fromValue = 0.f;animation.toValue = 40.f;[self.previewMask addAnimation:animation forKey:@\"changeBorderWith\"]; 效果如下： 用法5：用贝塞尔曲线做拟合计算贝塞尔曲线有个非常常用的动画效果，叫MetaBall算法。什么是MetaBall？就是我们平时看到的QQ的小红点消除啦~ 像下面这样。 这个是怎么实现的？ 矩形拟合首先我们需要了解一下简单的矩形拟合原理 如图所示的两个圆，我们通过给它添加一个矩形（绿色部分），矩形较短的两边分别顶住两个圆各自的一条直径上，然后通过改变矩形较长的两边的弧度（红色部分），达到拟合的效果。 这种做法当两个圆较小的时候，几乎是没有问题的。但是当圆稍微大点的时候，就会出现很明显的相交区域，拟合效果非常不好。 所以这种简单的矩形拟合在圆较大的时候是很不严格的。这个时候就需要更严谨的切线拟合。 切线拟合我们知道，之前的矩形拟合之所以才圆大的时候会出现拟合不严谨的情况。为什么？ 正如上图所示，两条曲线的画法都是由A1和B1为起点和终点，C点为控制点和A1、B2为起点和终点，C为控制点画出的二阶贝塞尔曲线。而要做到完美的拟合，必须达到的一点要求就是，贝塞尔曲线与圆的连接点，也就是A1、B1、A2、B2，他们与控制点C的连线，一定要是圆的切线。这样就不管圆大小怎么变，都不会出现明显的相交区域了。 图片引用: http://www.jianshu.com/p/55c721887568 于是，现在解决问题的关键就转变成了：如何计算这些拟合的关键点？ 图片引用: http://pandara.xyz/2015/10/27/ios_slime 我们现在要做的，就是求出点ABCDMN这六个点的坐标，就可以实现完美拟合了。结合上面两张图，通过三角函数的各种计算，我们最终可以得到如下代码： 123456789101112131415161718192021222324252627282930- (void)reloadBezierPath &#123; CGFloat r1 = self.trailDot.frame.size.width / 2.0f; CGFloat r2 = self.headDot.frame.size.width / 2.0f; CGFloat x1 = self.trailDot.center.x; CGFloat y1 = self.trailDot.center.y; CGFloat x2 = self.headDot.center.x; CGFloat y2 = self.headDot.center.y; CGFloat distance = sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)); CGFloat sinDegree = (x2 - x1) / distance; CGFloat cosDegree = (y2 - y1) / distance; CGPoint pointA = CGPointMake(x1 - r1 * cosDegree, y1 + r1 * sinDegree); CGPoint pointB = CGPointMake(x1 + r1 * cosDegree, y1 - r1 * sinDegree); CGPoint pointC = CGPointMake(x2 + r2 * cosDegree, y2 - r2 * sinDegree); CGPoint pointD = CGPointMake(x2 - r2 * cosDegree, y2 + r2 * sinDegree); CGPoint pointN = CGPointMake(pointB.x + (distance / 2) * sinDegree, pointB.y + (distance / 2) * cosDegree); CGPoint pointM = CGPointMake(pointA.x + (distance / 2) * sinDegree, pointA.y + (distance / 2) * cosDegree); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:pointA]; [path addLineToPoint:pointB]; [path addQuadCurveToPoint:pointC controlPoint:pointN]; [path addLineToPoint:pointD]; [path addQuadCurveToPoint:pointA controlPoint:pointM]; self.shapeLayer.path = path.CGPath; &#125; 现在我们已经可以做到非常完美拟合的时候了，这时候再结合前面的通过修改控制点来实现图形曲线变换，我们就可以做到类似QQ小红点消除一样的效果了，具体做法不再赘述。 Ending至此，我们已基本了解了贝塞尔曲线的历史出处公式性质及各种用法。在不断学习的过程中，我发现一些比较牛逼的实现方法，都涉及到了较多较复杂的数学公式，奈何大学高数没有好好学，导致需要回头去看很多东西，这也是这篇博客耗费了较多时间的原因之一。不过在掌握了这些基础和基本用法之后，就可以再去研究一下比较高级和酷炫的用法了，也留下了很多坑，会在以后慢慢填补的…如果以后还想补的话….文中如果有什么不足之处欢迎指正，这也是Share的目的之一。Have fun ~ 参考链接贝塞尔曲线维基百科UIBezierPath Class Reference贝塞尔曲线扫盲自定义缓冲函数iOS-UI进阶13 - 贝塞尔曲线和帧动画结合贝塞尔曲线开发的艺术","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shixiong.name/tags/iOS/"},{"name":"贝塞尔","slug":"贝塞尔","permalink":"https://shixiong.name/tags/贝塞尔/"},{"name":"动画","slug":"动画","permalink":"https://shixiong.name/tags/动画/"}]},{"title":"断点调试 autolayout","slug":"breakpoint-debug-autolayout","date":"2016-09-16T05:59:15.000Z","updated":"2019-07-30T02:17:17.769Z","comments":true,"path":"2016/09/16/breakpoint-debug-autolayout/","link":"","permalink":"https://shixiong.name/2016/09/16/breakpoint-debug-autolayout/","excerpt":"","text":"对于 iOS 和 OS X 开发者来说，Autolayout已经逐渐变成一个至关重要的开发工具。它让多屏幕适配变得小菜一碟(peasy)，但是有些时候它还是会把我们搞疯掉，因为它总是会出现那些啰嗦又没啥用处的错误警告。 就像这样: 12345678910111213Unable to simultaneously satisfy constraints.Probably at least one of the constraints in the following list is one you don't want.Try this:(1) look at each constraint and try to figure out which you don't expect;(2) find the code that added the unwanted constraint or constraints and fix it.(Note: If you're seeing NSAutoresizingMaskLayoutConstraints that you don't understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)(...........)Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful. 这么长的错误日志！！！！尼玛让谁看！！！ 但是我们仔细看一下，观察 NSLayoutConstraint 部分。发现它倒数第二行还是有给我们点希望去解决这个错误的。在 UIViewAlertForUnsatisfiableConstraints 添加一个Symbolic breakpoint 断点。既然这样，我们就去试一下… 尼玛！！ 毛用都没有啊！！它停在了线程堆栈上，然而LLDB依旧一片黑暗… 于是这里就有一个小技巧(Trick)，来让你的symbolic breakpoint变得更加有用。为你的ObjC项目添加 po [[UIWindow keyWindow] _autolayoutTrace] 或者为你的Swift项目添加 expr -l objc++ -O -- [[UIWindow keyWindow] _autolayoutTrace] 现在你就会在命令控制台看到你的UIView 的层次结构还有出现错误的地方。 12345UIWindow:0x7f9481c93360| •UIView:0x7f9481c9d680| | *UIView:0x7f9481c9d990- AMBIGUOUS LAYOUT for UIView:0x7f9481c9d990.minX&#123;id: 13&#125;, UIView:0x7f9481c9d990.minY&#123;id: 16&#125;| | *_UILayoutGuide:0x7f9481c9e160- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9e160.minY&#123;id: 17&#125;| | *_UILayoutGuide:0x7f9481c9ebb0- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9ebb0.minY&#123;id: 27&#125; 而当你在这个地方继续向下执行，它就会停在下一个你可能出现错误的地方。但是如果这样子你还是很难发现你的错误的话，你可以执行下面这个语句 12(lldb) e id $myView = (id) 0x7f9ea3d43410(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]] 先获取UIView，然后改变它的背景色 你就会看到出错误的视图主动显示出来了~ ps: 如果是手写Autolayout，推荐 Mansory，实在是好用！！ 关键是它的错误提示 12345678910Unable to simultaneously satisfy constraints......blah blah blah....( \"&lt;NSAutoresizingMaskLayoutConstraint:0x8887740 MASExampleDebuggingView:superview.height == 416&gt;\", \"&lt;MASLayoutConstraint:ConstantConstraint UILabel:messageLabel.height &gt;= 5000&gt;\", \"&lt;MASLayoutConstraint:BottomConstraint UILabel:messageLabel.bottom == MASExampleDebuggingView:superview.bottom - 10&gt;\", \"&lt;MASLayoutConstraint:ConflictingConstraint[0] UILabel:messageLabel.top == MASExampleDebuggingView:superview.top + 1&gt;\")Will attempt to recover by breaking constraint&lt;MASLayoutConstraint:ConstantConstraint UILabel:messageLabel.height &gt;= 5000&gt; 已经把出现错误的约束显示出来了，完全不需要我们去茫茫去偶遇~","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://shixiong.name/tags/iOS/"}]}]}